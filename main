//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

`define DE10_LITE // comment out this line if your board is the DE1-SoC board

// module 1: top-level module
module BEE271Lab4Part2(
	//////////// CLOCK //////////
`ifdef DE10_LITE
	input 		          		ADC_CLK_10, // not used
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50, // not used
`else
	input 		          		CLOCK2_50, // not used
	input 		          		CLOCK3_50, // not used
	input 		          		CLOCK4_50, // not used
	input 		          		CLOCK_50,  
`endif

	//////////// SEG7 //////////
`ifdef DE10_LITE
	output		     [7:0]		HEX0, // the present state of ex1_mealy is displayed
	output		     [7:0]		HEX1, // the present state of ex1_moore is displayed
	output		     [7:0]		HEX2, // the present state of ex3_mealy is displayed
	output		     [7:0]		HEX3, // the present state of ex3_moore is displayed
	output		     [7:0]		HEX4, // not used
	output		     [7:0]		HEX5, // not used
`else
	output		     [6:0]		HEX0, // the present state of ex1_mealy is displayed
	output		     [6:0]		HEX1, // the present state of ex1_moore is displayed
	output		     [6:0]		HEX2, // the present state of ex3_mealy is displayed
	output		     [6:0]		HEX3, // the present state of ex3_moore is displayed
	output		     [6:0]		HEX4, // not used
	output		     [6:0]		HEX5, // not used
`endif

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW
);

	//=======================================================
	//  REG/WIRE declarations
	//=======================================================
	wire div_clk; // to put the modulated clock signal into the four FSM designs
	wire [3:0] ex1_mealy_to_seg7; // wire from ex1_mealy to new_seg7
	wire [3:0] ex1_moore_to_seg7; // wire from ex1_moore to new_seg7
	wire [3:0] ex3_mealy_to_seg7; // wire from ex3_mealy to new_seg7
	wire [3:0] ex3_moore_to_seg7; // wire from ex3_moore to new_seg7

	//=======================================================
	//  Structural coding
	//=======================================================
	// include the clock_divider module
	clock_divider u_clock_divider (
`ifdef DE10_LITE
		.i_clock (MAX10_CLK1_50),
`else
		.i_clock (CLOCK_50),
`endif
		.reset_n (SW[9]),
		.o_clock (div_clk)
	);

	// include the example1_mealy module
	ex1_mealy u_ex1_mealy (
		.clk   (div_clk),
		.rst_n (SW[9]),
		.w     (SW[3]), // input
		.z     (LEDR[3]), // output
		.state (ex1_mealy_to_seg7) // additional output to see the present state
	);
	
	// include the new_seg7 module: the result of ex1_mealy is displayed on HEX0
	new_seg7 u_new_seg7_for_ex1_mealy (
		.hex (ex1_mealy_to_seg7),
		.led (HEX0[6:0])
	);
	
	
	// include the ex1_moore module
	ex1_moore u_ex1_moore (
		.clk   (div_clk),
		.rst_n (SW[9]),
		.w     (SW[3]), // input
		.z     (LEDR[4]), // output
		.state (ex1_moore_to_seg7) // additional output to see the present state
	);
	
	// include the new_seg7 module: the result of ex1_moore is displayed on HEX1
	new_seg7 u_new_seg7_for_ex1_moore (
		.hex (ex1_moore_to_seg7),
		.led (HEX1[6:0])
	);
	
	// include the ex3_mealy module
	ex3_mealy u_ex3_mealy (
		.clk   (div_clk),
		.rst_n (SW[9]),
		.w     (SW[5]), // input
		.z     (LEDR[5]), // output
		.state (ex3_mealy_to_seg7) // additional output to see the present state
	);
	
	// include the new_seg7 module: the result of ex3_mealy is displayed on HEX2
	new_seg7 u_new_seg7_for_ex3_mealy (
		.hex (ex3_mealy_to_seg7),
		.led (HEX2[6:0])
	);
	
	// include the ex3_mealy module
	ex3_moore u_ex3_moore (
		.clk   (div_clk),
		.rst_n (SW[9]),
		.w     (SW[5]), // input
		.z     (LEDR[6]), // output
		.state (ex3_moore_to_seg7) // additional output to see the present state
	);
	
	// include the new_seg7 module: the result of ex3_moore is displayed on HEX3
	new_seg7 u_new_seg7_for_ex3_moore (
		.hex (ex3_moore_to_seg7),
		.led (HEX3[6:0])
	);
	
	assign LEDR[9] = div_clk; // the divided clock signal is displayed on the leftmost LED

endmodule


// module 2: clock divider
// this module is used to lower the clock frequency (from 50MHz to 0.25Hz)
module clock_divider (
	input i_clock,
	input reset_n,
	output reg o_clock
);

	reg [27:0] cnt;

	always @(posedge i_clock) begin
		if (~reset_n) begin
			cnt <= 0;
		end else begin
			if (cnt == 100000000) begin
				cnt <= 0;
			end else begin
				cnt <= cnt + 1; // the cnt value is incremented by 1 whenever i_clock changes from 0 to 1
			end
		end
	end

	always @(posedge i_clock) begin
		if (~reset_n) begin
			o_clock <= 0;
		end else begin
			if (cnt == 100000000) begin
				o_clock <= ~o_clock; // o_clock is flipped when the cnt value is 100000000
			end
		end
	end

endmodule


// module 3: Mealy-typed FSM design example1 (automatically controlled vehicle)
module ex1_mealy (
	input clk,
	input rst_n,
	input w,
	output reg z,
	output [3:0] state // to display the present state
);
	// parameters used in this module
	localparam A = 1'b0,
	           B = 1'b1;
				  
	// internal signals
	reg p_state; // present state
	reg n_state; // next state
	
	// Part 1: update the present state using the computed next state (by Part 2)
	// this code is synthesized into flip-flops
	always @(posedge clk, negedge rst_n) begin
		if (rst_n == 0) begin
			p_state <= A;
		end else begin
			p_state <= n_state;
		end
	end
	
	// Part 2: calculate the next state
	// this code is synthesized into combinational circuits
	always @(*) begin
		case (p_state) 
			A: begin
				if (w == 1) begin
					n_state = B;
				end else begin
					n_state = A;
				end
			end
			B: begin
				if (w == 1) begin
					n_state = B;
				end else begin
					n_state = A;
				end
			end
			default: begin
				n_state = A;
			end
		endcase
	end
	
	// Part 3: calculate the output z
	// this code is synthesized into combinational circuits
	always @(*) begin
		case (p_state) 
			A: begin
				if (w == 1) begin
					z = 0;
				end else begin
					z = 0;
				end
			end
			B: begin
				if (w == 1) begin
					z = 1;
				end else begin
					z = 0;
				end
			end
			default: begin
				z = 0;
			end
		endcase
	end	
	
	// additional code to display the present state
	assign state = {3'b000, p_state}; // 3-bit binary number 000 is added to the variable "p_state" to fit into the 4-bit output "state" 
		
endmodule

// module 4: Moore-typed FSM design example1 (automatically controlled vehicle)
module ex1_moore (
	input clk,
	input rst_n,
	input w,
	output reg z,
	output [3:0] state // to display the present state
);
	always @(*) begin
    case (p_state)
    A: begin
    if (w == 1) begin
    n_state = B;
    end else begin
    n_state = A;
    end
    end
    B: begin
    n_state = C;
    end
    C: begin
    n_state = D;
    end
    D: begin
    n_state = A;
  end
		
endmodule


// module 5: Mealy-typed FSM design example3 (101 sequence detector)
module ex3_mealy (
	input clk,
	input rst_n,
	input w,
	output reg z,
	output [3:0] state // to display the present state
);
	case (p_state)
    A: begin
    // remains blank
    end
    B: begin
    R2out = 1;
    R3in = 1;
    end
    C: begin
    R1out = 1;
    R2in = 1;
    end
    D: begin
    R3out = 1;
    R1in = 1;
    done = 1;
    end
    default: begin
    R1in = 0;
    end
    endcase
    end
		
endmodule


// module 6: Moore-typed FSM design example3 (101 sequence detector)
module ex3_moore (
	input clk,
	input rst_n,
	input w,
	output reg z,
	output [3:0] state // to display the present state
);
	case (p_state)
    S: begin
    if (w == 1) begin
    n_state = S1;
    end else begin
    n_state = S;
    end
    end
    S1: begin
    if (w == 0) begin
    n_state = S10;
    end else begin
    n_state = S1;
    end
    end
    S10: begin
    if (w == 1) begin
    n_state = S101;
    end else begin
    n_state = S;
    end
    end
    S101: begin
    if (w == 1) begin
    n_state = S1;
    end else begin
    n_state = S10;
    end
    end
    default: begin
    n_state = S;
    end
		
endmodule


// module 7: 7-segment display driver
// this module displays a 4-bit binary signal on a 7-segment display as a hexadecimal character
module new_seg7 (
	 input [3:0] hex,
	output [6:0] led
);

	assign led[6] = /*copy and paste your Lab1-Part2 code*/;
	assign led[5] = /*copy and paste your Lab1-Part2 code*/;
	assign led[4] = /*copy and paste your Lab1-Part2 code*/;
	assign led[3] = /*copy and paste your Lab1-Part2 code*/;
	assign led[2] = /*copy and paste your Lab1-Part2 code*/;
	assign led[1] = /*copy and paste your Lab1-Part2 code*/;
	assign led[0] = /*copy and paste your Lab1-Part2 code*/;

endmodule
